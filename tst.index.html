import React, { useState } from 'react';

// メインアプリケーションコンポーネント
function App() {
  // アプリの現在のステージを管理するステート: 'input' (入力), 'categorization' (分類), 'results' (結果)
  const [stage, setStage] = useState('input');
  // ユーザーが入力する最大20個の文章を格納するステート
  const [sentences, setSentences] = useState(Array(20).fill(''));
  // 各文章の分類結果を格納するステート {インデックス: 'カテゴリ'}
  const [categories, setCategories] = useState({});
  // 分析結果（合計数、カテゴリごとの数、割合）を格納するステート
  const [analysisResults, setAnalysisResults] = useState(null);

  // 各モードの説明テキスト
  const modeExplanations = {
    A: "職業、家族の役割、コミュニティでの役割など、外部との関係性で自己を定義。",
    B: "性格、趣味、才能、感情、好みなど、個性的な側面で自己を定義。",
    C: "信念、価値観、目標、哲学、内面的な感情、自己成長の視点など、内省的な側面で自己を定義。",
    D: "身体的特徴、生物としての側面、人間としての普遍的な性質など、客観的・普遍的な側面で自己を定義。",
  };

  // 各モードのバーチャートとテキストの色クラスを返すヘルパー関数
  const getTailwindColorClass = (mode, type = 'bg') => {
    const colors = {
      A: type === 'bg' ? 'bg-blue-500' : 'text-blue-700',
      B: type === 'bg' ? 'bg-green-500' : 'text-green-700',
      C: type === 'bg' ? 'bg-yellow-500' : 'text-yellow-700',
      D: type === 'bg' ? 'bg-red-500' : 'text-red-700',
    };
    return colors[mode] || (type === 'bg' ? 'bg-gray-500' : 'text-gray-700');
  };

  // 文章入力フィールドの値が変更されたときのハンドラー
  const handleSentenceChange = (index, value) => {
    const newSentences = [...sentences];
    newSentences[index] = value;
    setSentences(newSentences);
  };

  // 「分類を開始する」ボタンがクリックされたときのハンドラー
  const handleStartAnalysis = () => {
    setStage('categorization');
  };

  // 文章のカテゴリが選択されたときのハンドラー
  const handleCategoryChange = (index, category) => {
    setCategories(prev => ({ ...prev, [index]: category }));
  };

  // 分析結果を計算し、「結果を表示する」ボタンがクリックされたときのハンドラー
  const calculateResults = () => {
    // 空でない有効な文章のみをフィルタリング
    const validSentences = sentences.filter(s => s.trim() !== '');
    const totalCount = validSentences.length;

    // 各カテゴリの数を初期化し、カウント
    const counts = { A: 0, B: 0, C: 0, D: 0 };
    validSentences.forEach((_, index) => {
      const category = categories[index];
      if (category) {
        counts[category]++;
      }
    });

    // 各カテゴリの割合を計算
    const percentages = {};
    Object.keys(counts).forEach(key => {
      percentages[key] = totalCount > 0 ? (counts[key] / totalCount) * 100 : 0;
    });

    // 分析結果をステートに保存し、ステージを「results」に設定
    setAnalysisResults({ totalCount, counts, percentages });
    setStage('results');
  };

  // 入力ステージのUIをレンダリングする関数
  const renderInputStage = () => (
    <div className="p-6 max-w-2xl mx-auto bg-white rounded-xl shadow-lg space-y-4 rounded-lg">
      <h2 className="text-3xl font-bold text-gray-800 text-center mb-4">自己理解アプリ</h2>
      <p className="text-gray-600 text-center mb-6 text-lg">「私は〜」で始まる文章を最大20個まで入力してください。自己をどのように認識しているかを探ります。</p>
      {Array.from({ length: 20 }).map((_, index) => (
        <div key={index} className="relative">
          <label htmlFor={`sentence-${index}`} className="sr-only">文章 {index + 1}</label>
          <input
            id={`sentence-${index}`}
            type="text"
            className="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200 pl-10"
            placeholder={`文章 ${index + 1} (例: 私は学生です)`}
            value={sentences[index]}
            onChange={(e) => handleSentenceChange(index, e.target.value)}
          />
          <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 font-bold">
            {index + 1}.
          </span>
        </div>
      ))}
      <p className="text-sm text-gray-500 text-right mt-2">現在の入力数: <span className="font-semibold">{sentences.filter(s => s.trim() !== '').length}</span>/20</p>
      <button
        onClick={handleStartAnalysis}
        className="w-full bg-blue-600 text-white p-3 rounded-md hover:bg-blue-700 transition duration-200 shadow-lg text-lg font-semibold rounded-lg"
      >
        分類を開始する
      </button>
    </div>
  );

  // 分類ステージのUIをレンダリングする関数
  const renderCategorizationStage = () => {
    const validSentences = sentences.filter(s => s.trim() !== '');
    if (validSentences.length === 0) {
      return (
        <div className="p-6 max-w-2xl mx-auto bg-white rounded-xl shadow-lg text-center rounded-lg">
          <p className="text-xl text-red-600 mb-4">入力された文章がありません。入力画面に戻ってください。</p>
          <button
            onClick={() => setStage('input')}
            className="mt-4 bg-gray-500 text-white p-3 rounded-md hover:bg-gray-600 transition duration-200 shadow-md font-semibold rounded-lg"
          >
            入力画面に戻る
          </button>
        </div>
      );
    }

    return (
      <div className="p-6 max-w-3xl mx-auto bg-white rounded-xl shadow-lg space-y-6 rounded-lg">
        <h2 className="text-3xl font-bold text-gray-800 text-center mb-4">文章を分類してください</h2>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6 text-sm text-gray-700">
          <div className="p-3 border border-gray-200 rounded-md bg-blue-50 rounded-lg shadow-sm">
            <p className="font-semibold text-blue-800">Aモード（社会的役割）</p>
            <p className="text-xs">{modeExplanations.A}</p>
          </div>
          <div className="p-3 border border-gray-200 rounded-md bg-green-50 rounded-lg shadow-sm">
            <p className="font-semibold text-green-800">Bモード（個人的特性）</p>
            <p className="text-xs">{modeExplanations.B}</p>
          </div>
          <div className="p-3 border border-gray-200 rounded-md bg-yellow-50 rounded-lg shadow-sm">
            <p className="font-semibold text-yellow-800">Cモード（内省的・価値観）</p>
            <p className="text-xs">{modeExplanations.C}</p>
          </div>
          <div className="p-3 border border-gray-200 rounded-md bg-red-50 rounded-lg shadow-sm">
            <p className="font-semibold text-red-800">Dモード（身体的特徴・普遍的自己）</p>
            <p className="text-xs">{modeExplanations.D}</p>
          </div>
        </div>

        {validSentences.map((sentence, index) => (
          <div key={index} className="border border-gray-200 rounded-lg p-4 bg-gray-50 shadow-md">
            <p className="text-lg font-medium text-gray-800 mb-3">
              <span className="font-bold text-blue-700">{index + 1}.</span> {sentence}
            </p>
            <div className="flex flex-wrap gap-4 justify-center">
              {['A', 'B', 'C', 'D'].map(mode => (
                <label key={mode} className="flex items-center space-x-2 cursor-pointer bg-white px-4 py-2 rounded-full shadow-sm hover:shadow-md transition duration-150">
                  <input
                    type="radio"
                    name={`category-${index}`}
                    value={mode}
                    checked={categories[index] === mode}
                    onChange={() => handleCategoryChange(index, mode)}
                    className="form-radio text-blue-600 h-5 w-5"
                  />
                  <span className="text-gray-700 font-medium">{mode}モード</span>
                </label>
              ))}
            </div>
          </div>
        ))}
        <button
          onClick={calculateResults}
          className="w-full bg-green-600 text-white p-3 rounded-md hover:bg-green-700 transition duration-200 shadow-lg text-lg font-semibold rounded-lg mt-6"
        >
          結果を表示する
        </button>
      </div>
    );
  };

  // 結果ステージのUIをレンダリングする関数
  const renderResultsStage = () => {
    if (!analysisResults) return null;

    const { totalCount, counts, percentages } = analysisResults;

    const data = Object.keys(counts).map(key => ({
      name: `${key}モード`,
      value: counts[key],
      percentage: percentages[key],
    }));

    // 分析結果の解説テキストを生成する関数
    const getInterpretation = () => {
      const validSentencesCount = sentences.filter(s => s.trim() !== '').length;

      if (validSentencesCount === 0) {
        return "分析対象の文章がありませんでした。入力画面に戻って文章を入力してください。";
      }

      let highestPercentage = -1;
      let dominantModes = [];

      Object.keys(percentages).forEach(key => {
        if (percentages[key] > highestPercentage) {
          highestPercentage = percentages[key];
          dominantModes = [key];
        } else if (percentages[key] === highestPercentage && highestPercentage > 0) {
          dominantModes.push(key);
        }
      });

      if (dominantModes.length === 0 || highestPercentage === 0) {
        return "入力された文章が均等に分類されたか、特定の傾向が低いようです。自己認識の多様性を示しているのかもしれません。";
      } else if (dominantModes.length === 1) {
        const dominantMode = dominantModes[0];
        return `あなたの自己認識は、主に<span class="font-bold ${getTailwindColorClass(dominantMode, 'text')}">${dominantMode}モード</span>に分類される傾向が強いようです。これは、あなたが自己を${modeExplanations[dominantMode]}と捉えていることを示唆しています。`;
      } else {
        const dominantModeNames = dominantModes.map(mode => `<span class="font-bold ${getTailwindColorClass(mode, 'text')}">${mode}モード</span>`).join('、');
        const interpretations = dominantModes.map(mode => modeExplanations[mode]).join('、または');
        return `あなたの自己認識は、主に${dominantModeNames}に分類される傾向が強いようです。これは、あなたが自己を${interpretations}と捉えていることを示唆しています。`;
      }
    };

    return (
      <div className="p-6 max-w-3xl mx-auto bg-white rounded-xl shadow-lg space-y-6 text-center rounded-lg">
        <h2 className="text-3xl font-bold text-gray-800 mb-6">分析結果</h2>
        <div className="text-xl text-gray-700 mb-4">
          <p>記述できた総数: <span className="font-bold text-blue-600">{totalCount}個</span></p>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          {Object.keys(counts).map(key => (
            <div key={key} className="p-4 border border-gray-200 rounded-lg bg-gray-50 shadow-sm rounded-lg">
              <p className="text-lg font-semibold text-gray-800">{key}モード</p>
              <p className="text-2xl font-bold text-indigo-700">{counts[key]}個</p>
              <p className="text-md text-gray-600">({percentages[key].toFixed(1)}%)</p>
            </div>
          ))}
        </div>

        {/* シンプルな棒グラフ (CSSとTailwindを使用) */}
        <div className="w-full bg-gray-100 rounded-lg p-4 mb-6 shadow-inner rounded-lg">
          <h3 className="text-xl font-semibold text-gray-700 mb-4">カテゴリ別割合</h3>
          {data.map((item, idx) => (
            <div key={idx} className="flex items-center mb-3">
              <div className="w-24 text-right pr-4 text-gray-700 font-medium">{item.name}</div>
              <div className="flex-1 bg-gray-200 rounded-full h-8 overflow-hidden shadow-inner">
                <div
                  className={`h-full rounded-full transition-all duration-500 ease-out ${getTailwindColorClass(item.name.slice(0, 1), 'bg')}`}
                  style={{ width: `${item.percentage}%` }}
                ></div>
              </div>
              <div className="w-16 text-left pl-4 font-semibold text-gray-800">{item.percentage.toFixed(1)}%</div>
            </div>
          ))}
        </div>

        {/* 結果の解説 */}
        <div className="text-left bg-blue-50 border border-blue-200 rounded-lg p-5 shadow-inner rounded-lg">
          <h3 className="text-xl font-bold text-blue-800 mb-3">結果の解説</h3>
          {/* dangerouslySetInnerHTML を使用して、HTMLとしてレンダリングされるようにする */}
          <p className="text-gray-800 leading-relaxed" dangerouslySetInnerHTML={{ __html: getInterpretation() }}></p>
        </div>

        <button
          onClick={() => {
            // アプリの状態をリセットして、最初からやり直せるようにする
            setStage('input');
            setSentences(Array(20).fill(''));
            setCategories({});
            setAnalysisResults(null);
          }}
          className="w-full bg-purple-600 text-white p-3 rounded-md hover:bg-purple-700 transition duration-200 shadow-lg text-lg font-semibold rounded-lg mt-6"
        >
          もう一度分析する
        </button>
      </div>
    );
  };

  return (
    // Tailwind CSSとFont-Interを読み込むための設定
    <div className="min-h-screen bg-gradient-to-br from-blue-100 to-indigo-200 flex items-center justify-center p-4 font-inter">
      <script src="https://cdn.tailwindcss.com"></script>
      <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
      {/* カスタムCSS: ラジオボタンの見た目を調整 */}
      <style>{`
        body {
          font-family: 'Inter', sans-serif;
        }
        .form-radio {
          -webkit-appearance: none;
          -moz-appearance: none;
          appearance: none;
          display: inline-block;
          vertical-align: middle;
          background-origin: border-box;
          user-select: none;
          flex-shrink: 0;
          border-radius: 100%;
          border-width: 2px;
          border-color: #CBD5E0; /* Tailwind gray-300 */
          background-color: #FFF;
          transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
        }
        .form-radio:checked {
          background-color: #2563EB; /* Tailwind blue-600 */
          border-color: #2563EB; /* Tailwind blue-600 */
        }
        .form-radio:checked + span {
          color: #2563EB; /* Tailwind blue-600 */
        }
        /* すべての要素に rounded corners を適用 */
        * {
            border-radius: 0.5rem; /* rounded-lg と同じ */
        }
      `}</style>

      {/* 現在のステージに応じてUIをレンダリング */}
      {stage === 'input' && renderInputStage()}
      {stage === 'categorization' && renderCategorizationStage()}
      {stage === 'results' && renderResultsStage()}
    </div>
  );
}

export default App;
